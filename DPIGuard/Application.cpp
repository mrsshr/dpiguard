#include "StdAfx.h"
#include "Application.h"
#include "ApplicationVersion.h"
#include "BufferReader.h"
#include "HttpRequestParser.h"
#include "Utils.h"

Application theApp;

static wchar_t SERVICE_NAME[] = L"DPIGuard";

static const char* WINDIVERT_HTTPS_FILTER = \
"!loopback && outbound && (ip || ipv6) && length <= 4096 && tcp.PayloadLength >= 16 &&"
"("
"tcp.DstPort == 80 || "
"(tcp.DstPort == 443 && tcp.Payload[0] == 22 && tcp.Payload[1] == 3 && tcp.Payload[2] == 1)"
")";

Application::Application()
    : m_appConfigModifiedTime(), m_serviceMode(false), m_serviceStatusHandle(nullptr)
    , m_configMonitorStop(false), m_commandType(CommandType::None)
{
}

int Application::Run(int argc, wchar_t* argv[])
{
    if (!ParseCommandLine(argc, argv))
    {
        CommandHelp();
        return 1;
    }

    switch (m_commandType)
    {
    case CommandType::Version:
        return CommandVersion();
    case CommandType::Install:
        return CommandInstall();
    case CommandType::Uninstall:
        return CommandUninstall();
    default:
        break;
    }

    if (!StartServiceMode())
        StartMainThread();

    WaitMainThread();

    return 0;
}

int Application::CommandHelp()
{
    static const char* MESSAGE = \
        "Usage: DPIGuard [OPTION]\n"
        "\n"
        "  -h, --help               display this help and exit\n"
        "      --version            display version information and exit\n"
        "      --install            install DPIGuard service\n"
        "      --uninstall          uninstall DPIGuard service\n";

    printf(MESSAGE);
    return 0;
}

int Application::CommandVersion()
{
    static const char* MESSAGE = \
        "DPIGuard %s\n"
        "\n"
        "Copyright (C) 2021 mrsshr https://github.com/mrsshr/dpiguard\n"
        "License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\n"
        "This is free software: you are free to change and redistribute it.\n"
        "There is NO WARRANTY, to the extent permitted by law.\n"
        "\n"
        "* yaml-cpp https://github.com/jbeder/yaml-cpp\n"
        "\n"
        "  Copyright (c) 2008-2015 Jesse Beder.\n"
        "\n"
        "  Permission is hereby granted, free of charge, to any person obtaining a copy\n"
        "  of this software and associated documentation files (the \"Software\"), to deal\n"
        "  in the Software without restriction, including without limitation the rights\n"
        "  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
        "  copies of the Software, and to permit persons to whom the Software is\n"
        "  furnished to do so, subject to the following conditions:\n"
        "\n"
        "  The above copyright notice and this permission notice shall be included in\n"
        "  all copies or substantial portions of the Software.\n"
        "\n"
        "  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
        "  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
        "  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
        "  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
        "  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
        "  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
        "  THE SOFTWARE.\n"
        "\n"
        "* Boost https://www.boost.org/\n"
        "\n"
        "  Boost Software License - Version 1.0 - August 17th, 2003\n"
        "\n"
        "  Permission is hereby granted, free of charge, to any person or organization\n"
        "  obtaining a copy of the software and accompanying documentation covered by\n"
        "  this license (the \"Software\") to use, reproduce, display, distribute,\n"
        "  execute, and transmit the Software, and to prepare derivative works of the\n"
        "  Software, and to permit third-parties to whom the Software is furnished to\n"
        "  do so, all subject to the following:\n"
        "\n"
        "  The copyright notices in the Software and this entire statement, including\n"
        "  the above license grant, this restriction and the following disclaimer,\n"
        "  must be included in all copies of the Software, in whole or in part, and\n"
        "  all derivative works of the Software, unless such copies or derivative\n"
        "  works are solely in the form of machine-executable object code generated by\n"
        "  a source language processor.\n"
        "\n"
        "  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
        "  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
        "  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n"
        "  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n"
        "  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n"
        "  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n"
        "  DEALINGS IN THE SOFTWARE.\n";

    printf(MESSAGE, APPLICATION_VERSION);
    return 0;
}

int Application::CommandInstall()
{
    SC_HANDLE scmHandle = nullptr;
    SC_HANDLE serviceHandle = nullptr;

    BOOL started = FALSE;

    std::wstring binaryPath;
    std::wstring appPath = Utils::GetApplicationPath();

    binaryPath.reserve(appPath.size() + 2);
    binaryPath.push_back(L'"');
    binaryPath.append(appPath);
    binaryPath.push_back(L'"');

    scmHandle = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
    if (scmHandle == nullptr)
    {
        printf("[-] Failed to open service control manager: %u", GetLastError());
        goto cleanup;
    }

    serviceHandle = CreateServiceW(
        scmHandle, SERVICE_NAME, SERVICE_NAME,
        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_IGNORE,
        binaryPath.c_str(),
        nullptr, nullptr, nullptr, nullptr, nullptr);

    if (serviceHandle != nullptr)
    {
        printf("[+] The service has been installed successfully.\n");
    }
    else
    {
        DWORD lastError = GetLastError();

        switch (lastError)
        {
        case ERROR_SERVICE_EXISTS:
            serviceHandle = OpenServiceW(scmHandle, SERVICE_NAME, SERVICE_ALL_ACCESS);
            if (serviceHandle == nullptr)
            {
                printf("[-] Failed to open service: %u\n", GetLastError());
                goto cleanup;
            }

            break;
        default:
            printf("[-] Failed to create service: %u", GetLastError());
            goto cleanup;
        }
    }

    if (StartServiceW(serviceHandle, 0, nullptr) != FALSE)
        printf("[+] The service started successfully.\n");
    else
        printf("[-] Failed to start service: %u\n", GetLastError());

cleanup:
    if (serviceHandle != nullptr)
        CloseServiceHandle(serviceHandle);
    if (scmHandle != nullptr)
        CloseServiceHandle(scmHandle);

    return 0;
}

int Application::CommandUninstall()
{
    SC_HANDLE scmHandle = nullptr;
    SC_HANDLE serviceHandle = nullptr;
    SERVICE_STATUS ss = { 0 };

    scmHandle = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
    if (scmHandle == nullptr)
    {
        printf("[-] Failed to open service control manager: %u", GetLastError());
        goto cleanup;
    }

    serviceHandle = OpenServiceW(scmHandle, SERVICE_NAME, SERVICE_ALL_ACCESS);
    if (serviceHandle == nullptr)
    {
        DWORD lastError = GetLastError();

        switch (lastError)
        {
        case ERROR_SERVICE_DOES_NOT_EXIST:
            printf("[+] The service is not installed.\n");
            goto cleanup;
        default:
            printf("[-] Failed to open service control manager: %u", GetLastError());
            goto cleanup;
        }
    }

    if (ControlService(serviceHandle, SERVICE_CONTROL_STOP, &ss))
    {
        ULONGLONG startTime = GetTickCount64();
        bool stopped = false;

        do
        {
            if (ss.dwCurrentState == SERVICE_STOPPED)
            {
                stopped = true;
                break;
            }

            if (GetTickCount64() - startTime >= 15000)
                break;

            Sleep(100);
        } while (QueryServiceStatus(serviceHandle, &ss));

        if (stopped)
            printf("[+] The service has been stopped successfully.\n");
        else
            printf("[-] Failed to stop service: Request timed out\n");
    }
    else
    {
        DWORD lastError = GetLastError();

        switch (lastError)
        {
        case ERROR_SERVICE_NOT_ACTIVE:
            break;
        default:
            printf("[-] Failed to stop service: %u", GetLastError());
            goto cleanup;
        }
    }

    if (DeleteService(serviceHandle) != FALSE)
    {
        printf("[+] The service has been uninstalled successfully.\n");
    }
    else
    {
        DWORD lastError = GetLastError();

        switch (lastError)
        {
        case ERROR_SERVICE_MARKED_FOR_DELETE:
            printf("[!] The service has been marked for deletion.\n");
            break;
        default:
            printf("[-] Failed to delete service: %u\n", lastError);
            break;
        }
    }

cleanup:
    if (serviceHandle != nullptr)
        CloseServiceHandle(serviceHandle);
    if (scmHandle != nullptr)
        CloseServiceHandle(scmHandle);

    return 0;
}

bool Application::ParseCommandLine(int argc, wchar_t* argv[])
{
    bool accepted = true;

    for (int i = 1; i < argc; i++)
    {
        if (wcscmp(argv[i], L"-h") == 0 ||
            wcscmp(argv[i], L"--help") == 0)
        {
            accepted = false;
            break;
        }
        else if (wcscmp(argv[i], L"--version") == 0)
        {
            if (m_commandType != CommandType::None)
            {
                accepted = false;
                break;
            }

            m_commandType = CommandType::Version;
        }
        else if (wcscmp(argv[i], L"--install") == 0)
        {
            if (m_commandType != CommandType::None)
            {
                accepted = false;
                break;
            }

            m_commandType = CommandType::Install;
        }
        else if (wcscmp(argv[i], L"--uninstall") == 0)
        {
            if (m_commandType != CommandType::None)
            {
                accepted = false;
                break;
            }

            m_commandType = CommandType::Uninstall;
        }
        else
        {
            accepted = false;
            break;
        }
    }

    return accepted;
}

void Application::Main()
{
    printf("[+] Loading configuration\n");

    m_appConfigPath = Utils::GetApplicationConfigPath();

    if (!m_appConfig.LoadFile(m_appConfigPath))
    {
        printf("[-] The configuration file is invalid or corrupted. Aborting\n");

        ReportStopped();
        return;
    }

    m_appConfig.SaveFile(m_appConfigPath);

    StartConfigMonitor();

    if (!m_serviceMode)
        SetConsoleCtrlHandler(&Application::ConsoleCtrlHandlerProc, TRUE);

    try
    {
        WinDivertPacket packet;

        printf("[+] Initializing packet filter module\n");

        if (!m_divert.Open(WINDIVERT_HTTPS_FILTER))
            throw std::system_error(GetLastError(), std::system_category());

        printf("[+] Initialization complete\n");

        ReportRunning();

        while (m_divert.Recv(packet))
        {
            if (packet.Dissect())
            {
                if (HandlePacket(packet))
                    continue;
            }

            m_divert.Send(packet);
        }

        m_divert.Close();
    }
    catch (const std::exception& e)
    {
        printf("[-] Unexpected error. Aborting (%s)\n", e.what());
    }

    StopConfigMonitor();
    StopWinDivert();

    ReportStopped();

    printf("[+] Stopped\n");
}

void Application::ConfigMonitor()
{
    bool result = false;

    while (!result)
    {
        std::unique_lock<std::mutex> locked(m_configMonitorLock);

        result = m_configMonitorCv.wait_for(locked, std::chrono::seconds(5), [&]() {
            return m_configMonitorStop;
        });

        if (!result) {
            if (!Utils::CheckFileModified(m_appConfigPath.c_str(), m_appConfigModifiedTime))
                continue;

            if (!m_appConfig.LoadFile(m_appConfigPath))
            {
                printf("[-] The new configuration file is invalid or corrupted.\n");
                continue;
            }
            
            printf("[+] The configuration file has been reloaded.\n");
        }
    }
}

bool Application::HandlePacket(WinDivertPacket& packet)
{
    if (!packet.IPv4() && !packet.IPv6())
        return false;

    if (!packet.Tcp())
        return false;

    switch (Utils::ntohs(packet.Tcp()->DstPort))
    {
    case 80:
        return HandleHttp(packet);
    case 443:
        return HandleHttps(packet);
    default:
        break;
    }

    return false;
}

bool Application::HandleHttp(WinDivertPacket& packet)
{
    if (!packet.Data())
        return false;

    try
    {
        const uint8_t* data = packet.Data();
        uint32_t dataLength = packet.DataLength();

        HttpRequestParser parser;
        HttpRequestParser::Result result = parser.Parse(data, dataLength);

        if (result == HttpRequestParser::Result::Bad)
            return false;

        const std::array<int, 4>* header = parser.GetHeader("Host");
        if (header == nullptr)
            return false;

        int valueBegin = header->at(2);
        int valueEnd = header->at(3);

        std::string hostName(data + valueBegin, data + valueEnd);

        return HandleHttpFragmentation(packet, hostName, valueBegin);
    }
    catch (const std::exception& e)
    {
        printf("[-] Unexpected error while parsing HTTP packet (%s)\n", e.what());

        // TODO Dump raw packet bytes
    }

    return false;
}

bool Application::HandleHttps(WinDivertPacket& packet)
{
    if (!packet.Data())
        return false;

    try
    {
        BufferReader reader(packet.Data(), packet.DataLength());

        // Content Type: Handshake (22)
        // Version: TLS 1.0 (0x0301)
        // Length: 512

        try
        {
            uint8_t contentType = reader.UInt8();
            uint16_t version = Utils::ntohs(reader.UInt16());
            uint16_t length = Utils::ntohs(reader.UInt16());

            if (contentType != 22 || version != 0x0301)
                return false;
        }
        catch (const std::out_of_range&)
        {
            return false;
        }

        // Handshake Type: Client Hello (1)
        // Length: 508
        // Version: TLS 1.2 (0x0303)
        // Random: 19ecfc70399dbe45a24a73d099ba4a3b8ad91042e90105c8e6271fb93cd6b78f
        // Session ID Length: 32
        // Session ID: 51ca63b4499b93beba73f581ef06c088abc7cd0e7a21166bd60dce014a00b321
        // Cipher Suites Length: 62
        // Cipher Suites (31 suites)
        // Compression Methods Length: 1
        // Compression Methods (1 method)

        uint8_t handshakeType = reader.UInt8();
        if (handshakeType != 1)
            return false;

        uint8_t handshakeLengthBytes[4];
        handshakeLengthBytes[0] = 0;
        handshakeLengthBytes[1] = reader.UInt8();
        handshakeLengthBytes[2] = reader.UInt8();
        handshakeLengthBytes[3] = reader.UInt8();
        uint8_t handshakeLength = Utils::ntohl(*reinterpret_cast<uint32_t*>(handshakeLengthBytes));

        uint16_t handshakeVersion = Utils::ntohs(reader.UInt16());
        // TLS 1.0, TLS 1.1, TLS 1.2
        if (handshakeVersion != 0x0301 && handshakeVersion != 0x0302 && handshakeVersion != 0x0303)
            return false;

        reader.Forward(32);

        uint8_t sessionIdLength = reader.UInt8();
        reader.Forward(sessionIdLength);

        uint16_t cipherSuitesLength = Utils::ntohs(reader.UInt16());
        reader.Forward(cipherSuitesLength);

        uint8_t compressionMethodsLength = reader.UInt8();
        reader.Forward(compressionMethodsLength);

        // Extensions Length: 373
        uint16_t extensionsLength = Utils::ntohs(reader.UInt16());
        while (extensionsLength)
        {
            // Extension: server_name (len=14)
            // Type: server_name (0)
            // Length: 14

            uint16_t extensionType = Utils::ntohs(reader.UInt16());
            uint16_t extensionLength = Utils::ntohs(reader.UInt16());

            size_t nextOffset = reader.Offset() + extensionLength;

            if (extensionType == 0)
            {
                // Server Name list length: 12

                // Extension: server_name (len=14)
                // Type: server_name (0)
                // Length: 14

                uint16_t serverNameListLength = Utils::ntohs(reader.UInt16());

                uint16_t serverNameType = reader.UInt8();
                uint16_t serverNameLength = Utils::ntohs(reader.UInt16());

                size_t serverNameOffset = reader.Offset();

                const char* serverNameBuffer = reinterpret_cast<const char*>(reader.Consume(serverNameLength));
                std::string serverName = std::string(serverNameBuffer, serverNameBuffer + serverNameLength);

                return HandleTlsFragmentation(packet, serverName, serverNameOffset);
            }

            reader.Offset(nextOffset);

            uint32_t totalExtensionLength = sizeof(uint16_t) * 2 + extensionLength;
            if (extensionsLength < totalExtensionLength)
                break;

            extensionsLength -= totalExtensionLength;
        }
    }
    catch (const std::exception& e)
    {
        printf("[-] Unexpected error while parsing TLS packet (%s)\n", e.what());

        // TODO Dump raw packet bytes
    }

    return false;
}

bool Application::HandleHttpFragmentation(WinDivertPacket& packet, const std::string& hostName, size_t hostNameOffset)
{
    std::shared_ptr<const ApplicationConfig::DomainConfig> domainConfig = m_appConfig.GetDomainConfig(hostName);

    if (!domainConfig)
    {
        printf("[+] HTTP[Skip]: %s\n", hostName.c_str());
        return false;
    }

    if (!domainConfig->httpFragmentationEnabled)
        return false;

    printf("[+] HTTP[OK]: %s\n", hostName.c_str());
    return DoTcpFragmentation(packet, domainConfig->httpFragmentationOffset, domainConfig->httpFragmentationOutOfOrder);
}

bool Application::HandleTlsFragmentation(WinDivertPacket& packet, const std::string& serverName, size_t serverNameOffset)
{
    std::shared_ptr<const ApplicationConfig::DomainConfig> domainConfig = m_appConfig.GetDomainConfig(serverName);

    if (!domainConfig)
    {
        printf("[+] TLS[Skip]: %s\n", serverName.c_str());
        return false;
    }

    if (!domainConfig->tlsFragmentationEnabled)
        return false;

    printf("[+] TLS[OK]: %s\n", serverName.c_str());
    return DoTcpFragmentation(packet, domainConfig->tlsFragmentationOffset, domainConfig->tlsFragmentationOutOfOrder);
}

bool Application::DoTcpFragmentation(WinDivertPacket& packet, size_t offset, bool outOfOrder)
{
    size_t headerLength = packet.Data() - packet.Buffer().data();

    if (packet.DataLength() <= offset)
        return false;

    size_t firstDataOffset = 0;
    size_t firstDataLength = offset;
    size_t secondDataOffset = firstDataOffset + firstDataLength;
    size_t secondDataLength = packet.DataLength() - secondDataOffset;

    WinDivertPacket firstPacket(packet);
    WinDivertPacket secondPacket(packet);

    firstPacket.Buffer().resize(headerLength + firstDataOffset + firstDataLength);
    if (firstPacket.IPv4())
        firstPacket.IPv4()->Length = Utils::htons(static_cast<uint16_t>(firstPacket.Buffer().size()));
    else
        firstPacket.IPv6()->Length = Utils::htons(static_cast<uint16_t>(firstPacket.Buffer().size()));
    firstPacket.RecalcChecksum();

    secondPacket.Buffer().resize(headerLength + secondDataLength);
    memcpy(secondPacket.Data(), packet.Data() + secondDataOffset, secondDataLength);
    if (secondPacket.IPv4())
        secondPacket.IPv4()->Length = Utils::htons(static_cast<uint16_t>(secondPacket.Buffer().size()));
    else
        secondPacket.IPv6()->Length = Utils::htons(static_cast<uint16_t>(secondPacket.Buffer().size()));
    secondPacket.Tcp()->SeqNum = Utils::htonl(Utils::ntohl(firstPacket.Tcp()->SeqNum) + static_cast<uint32_t>(firstDataLength));
    secondPacket.RecalcChecksum();

    if (outOfOrder)
        std::swap(firstPacket, secondPacket);

    m_divert.Send(firstPacket);
    m_divert.Send(secondPacket);

    return true;
}

void Application::StartMainThread()
{
    m_mainThread = std::make_unique<std::thread>(&Application::Main, this);
}

void Application::WaitMainThread()
{
    std::unique_lock<std::mutex> locked(m_mainThreadLock);

    if (m_mainThread && m_mainThread->joinable())
        m_mainThread->join();
}

void Application::StartConfigMonitor()
{
    Utils::CheckFileModified(m_appConfigPath.c_str(), m_appConfigModifiedTime);

    m_configMonitorThread.reset(new std::thread(&Application::ConfigMonitor, this));
}

void Application::StopConfigMonitor()
{
    {
        std::unique_lock<std::mutex> locked(m_configMonitorLock);
        m_configMonitorStop = true;
    }

    m_configMonitorCv.notify_all();

    if (m_configMonitorThread->joinable())
        m_configMonitorThread->join();
}

void Application::StopWinDivert()
{
    SC_HANDLE scmHandle = nullptr;
    SC_HANDLE serviceHandle = nullptr;

    scmHandle = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
    if (scmHandle == nullptr)
        return;

    serviceHandle = OpenServiceW(scmHandle, L"WinDivert", SERVICE_ALL_ACCESS);
    if (serviceHandle == nullptr)
    {
        CloseServiceHandle(scmHandle);
        return;
    }

    SERVICE_STATUS ss = { 0 };
    ControlService(serviceHandle, SERVICE_CONTROL_STOP, &ss);

    CloseServiceHandle(serviceHandle);
    CloseServiceHandle(scmHandle);
}

BOOL Application::ConsoleCtrlHandler(DWORD ctrlType)
{
    if (ctrlType == CTRL_C_EVENT ||
        ctrlType == CTRL_BREAK_EVENT ||
        ctrlType == CTRL_CLOSE_EVENT ||
        ctrlType == CTRL_LOGOFF_EVENT ||
        ctrlType == CTRL_SHUTDOWN_EVENT)
    {
        m_divert.Shutdown();
        WaitMainThread();
        return TRUE;
    }

    return FALSE;
}

BOOL WINAPI Application::ConsoleCtrlHandlerProc(DWORD dwCtrlType)
{
    return theApp.ConsoleCtrlHandler(dwCtrlType);
}

bool Application::StartServiceMode()
{
    SERVICE_TABLE_ENTRYW serviceTableEntries[] = {
        { SERVICE_NAME, &Application::ServiceMainProc },
        { nullptr, nullptr }
    };

    if (StartServiceCtrlDispatcherW(serviceTableEntries) == FALSE)
        return false;

    return true;
}

void Application::ServiceMain(DWORD args, wchar_t* argv[])
{
    m_serviceMode = true;

    m_serviceStatusHandle = RegisterServiceCtrlHandlerExW(SERVICE_NAME, &Application::ServiceCtrlHandlerProc, this);
    if (m_serviceStatusHandle == nullptr)
        return;

    ReportStartPending();

    StartMainThread();
}

DWORD Application::ServiceCtrlHandler(DWORD control, DWORD eventType, LPVOID eventData)
{
    switch (control)
    {
    case SERVICE_CONTROL_STOP:
        ReportStopPending();
        m_divert.Shutdown();
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    default:
        return ERROR_CALL_NOT_IMPLEMENTED;
    }

    return NO_ERROR;
}

void Application::ReportStartPending()
{
    if (m_serviceStatusHandle == nullptr)
        return;

    SERVICE_STATUS ss = { 0 };
    ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ss.dwCurrentState = SERVICE_START_PENDING;
    ss.dwControlsAccepted = 0;
    SetServiceStatus(m_serviceStatusHandle, &ss);
}

void Application::ReportRunning()
{
    if (m_serviceStatusHandle == nullptr)
        return;

    SERVICE_STATUS ss = { 0 };
    ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ss.dwCurrentState = SERVICE_RUNNING;
    ss.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    SetServiceStatus(m_serviceStatusHandle, &ss);
}

void Application::ReportStopPending()
{
    if (m_serviceStatusHandle == nullptr)
        return;

    SERVICE_STATUS ss = { 0 };
    ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ss.dwCurrentState = SERVICE_STOP_PENDING;
    ss.dwControlsAccepted = 0;
    SetServiceStatus(m_serviceStatusHandle, &ss);
}

void Application::ReportStopped()
{
    if (m_serviceStatusHandle == nullptr)
        return;

    SERVICE_STATUS ss = { 0 };
    ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ss.dwCurrentState = SERVICE_STOPPED;
    ss.dwControlsAccepted = 0;
    SetServiceStatus(m_serviceStatusHandle, &ss);
}

void WINAPI Application::ServiceMainProc(DWORD args, wchar_t* argv[])
{
    theApp.ServiceMain(args, argv);
}

DWORD WINAPI Application::ServiceCtrlHandlerProc(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)
{
    Application* _this = reinterpret_cast<Application*>(lpContext);
    return _this->ServiceCtrlHandler(dwControl, dwEventType, lpEventData);
}
